% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{amsfonts}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{GaussPy Documentation}
\date{February 12, 2016}
\release{1.0}
\author{Robert Lindner, Carlos Vera-Ciro}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:welcome-to-gausspy-s-documentation}\label{intro:introduction}\label{intro:intro}\label{intro::doc}
When interpreting data, it is useful to fit models made up of parametrized functions. Gaussian functions, described simply by three parameters and often physically well-motivated, provide a convenient basis set of functions for such a model. However, any set of Gaussian functions is not an orthogonal basis, and therefore any solution implementing them will not be unique. Furthermore, determining fits to spectra involving more than one Gaussian function is complex, and the crucial step of guessing the number of functions and their parameters is not straightforward. Typically, reasonable fits can be determined iteratively and by-eye. However, for large sets of data, analysis by-eye requires an unreasonable amount of processing time and is unfeasible.

This document describes the installation and use of GaussPy, a code for implementing an algorithm called Autonomous Gaussian Decomposition (AGD). AGD using computer vision and machine learning techniques to provide optimized initial guesses for the parameters of a multi-component Gaussian model automatically and efficiently. The speed and adaptability of AGD allow it to interpret large volumes of spectral data efficiently. Although it was initially designed for applications in radio astrophysics, AGD can be used to search for one-dimensional Gaussian (or any other single-peaked spectral profile)-shaped components in any data set.

To determine how many Gaussian functions to include in a model and what their parameters are, AGD uses a technique called derivative spectroscopy. The derivatives of a spectrum can efficiently identify shapes within that spectrum corresponding to the underlying model, including gradients, curvature and edges. The details of this method are described fully in \href{http://iopscience.iop.org/article/10.1088/0004-6256/149/4/138/meta}{Lindner et al. (2015), AJ, 149, 138}.


\chapter{Installation}
\label{install:installation}\label{install::doc}\label{install:install}

\section{Dependencies}
\label{install:dependencies}\begin{itemize}
\item {} 
\href{http://www.numpy.org/}{Python 2.7}

\item {} 
\href{http://www.numpy.org/}{Numpy}

\item {} 
\href{http://www.scipy.org/}{Scipy}

\item {} 
\href{http://www.h5py.org/}{h5py}

\item {} 
\href{http://www.gnu.org/software/gsl/}{GNU Scientific Library (GSL)}

\end{itemize}

If you do not already have Python 2.7, you can
install the
\href{https://store.continuum.io/cshop/anaconda/}{Anaconda Scientific Python distribution},
which comes pre-loaded with Numpy, Scipy, and h5py.

To obtain GSL:

\begin{Verbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get install libgsl0\PYGZhy{}dev
\end{Verbatim}


\section{Download GaussPy}
\label{install:download-gausspy}
Download GaussPy from...


\section{Installing GaussPy}
\label{install:installing-gausspy}
To install make sure that all
dependences are already installed and properly linked to python
--python has to be able to load them--. Then cd to the local directory
containing gausspy and type

\$ python setup.py install

If you don't have root access and/or wish a local installation of
gausspy then use

\$ python setup.py install --user

change the `requires' statement in setup.py to include scipy and lmfit


\chapter{Quickstart Tutorial}
\label{tutorial::doc}\label{tutorial:quickstart-tutorial}\label{tutorial:tutorial}
Before applying AGD to your data using GaussPy, you must first train the AGD algorithm to determine the optimal value of the smoothing parameter \(\alpha\). This training requires you to apply AGD to a dataset with known underlying Gaussian decomposition. In other words, you need to have a training dataset for which you know (or have an estimate of) the true Gaussian model. This training dataset can be composed of real (i.e. previously analyzed) or synthetically-constructed data, for which you have prior inofmraiton about the underlying correct decomposition. This prior information is used to maximize the model accuracy by calibrating the \(\alpha\) parameter used by AGD.


\section{Creating a Synthetic Training Dataset}
\label{tutorial:creating-a-synthetic-training-dataset}
Training datasets can be constructed by adding Gaussian functions with
parameters drawn from known distributions with known
uncertainties. For example, we can create a mock dataset with
\code{NSPECTRA}-realizations of the function
\phantomsection\label{tutorial:equation-spectra}\begin{gather}
\begin{split}S(x_i) = \sum_{k=1}^{\texttt{NCOMPS}} {\texttt{AMP}_k} \exp\left[-\frac{4\ln 2 (x_i
- \texttt{MEAN}_k)^2}{\texttt{FWHM}_k^2} \right] + \texttt{NOISE},
  \qquad i = 1, \cdots, \texttt{NCHANNELS}\end{split}\label{tutorial-spectra}
\end{gather}
where
\begin{enumerate}
\item {} 
\code{NSPECTRA} is then the number of synthetic spectra to be created

\item {} 
\code{NCOMPS} is the number of components in each synthetic spectrum

\item {} 
\code{(AMP, MEAN, FWHM)} are the parameters of each Gaussian component

\item {} 
\code{NOISE} is the level of noise introduced in each spectrum

\end{enumerate}

In the next example we will show how to implement this in python. We
have made the following assumptions
\begin{enumerate}
\item {} 
\(\mathrm{NOISE} \sim N(0, {\rm RMS}) + f \times {\rm RMS}\)
with \code{RMS=0.05} and \(f=0\)

\item {} 
\code{NCOMPS = 4} \textbf{This number is fixed, i.e. not random}

\item {} 
\code{NCHANNELS = 512} This number sets the resolution of each
spectrum. \textbf{Does this number need to be the same for all spectra in
AGD?}

\item {} 
\(\mathrm{AMP} \sim \mu(5 \mathrm{RMS}, 25 \mathrm{RMS})\),
this way we ensure that every spectral feature is above the noise
level. Spectra with a more dominant contribution from the noise can
also be generated and used as training sets for AGD

\item {} 
\(\mathrm{FWHM} \sim \mu(10, 35)\) and \(\mathrm{MEAN}
\sim \mu(0.25, 0.75) \times \mathrm{NCHANNELS}\), note that for our
choice of the number of channels, this selection of \code{FWHM}
ensures that even the wider component can be fit within the
spectrum.

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} GaussPy Example 1}
\PYG{c+c1}{\PYGZsh{} Create spectra with Gaussian profiles}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{pickle}

\PYG{c+c1}{\PYGZsh{} Specify the number of spectral channels (NCHANNELS)}
\PYG{n}{NCHANNELS} \PYG{o}{=} \PYG{l+m+mi}{512}
\PYG{c+c1}{\PYGZsh{} Specify the number of spectra (NSPECTRA)}
\PYG{n}{NSPECTRA} \PYG{o}{=} \PYG{l+m+mi}{1000}

\PYG{c+c1}{\PYGZsh{} Estimate of the root\PYGZhy{}mean\PYGZhy{}square uncertainty per channel (RMS)}
\PYG{n}{RMS} \PYG{o}{=} \PYG{l+m+mf}{0.05}

\PYG{c+c1}{\PYGZsh{} Estimate the mean number of Gaussian functions to add per spectrum (NCOMPS)}
\PYG{n}{NCOMPS} \PYG{o}{=} \PYG{l+m+mi}{4}

\PYG{c+c1}{\PYGZsh{} Specify the min\PYGZhy{}max range of possible properties of the Gaussian function paramters:}
\PYG{c+c1}{\PYGZsh{} Amplitude (AMP)}
\PYG{n}{AMP\PYGZus{}lims} \PYG{o}{=} \PYG{p}{[}\PYG{n}{RMS} \PYG{o}{*} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{RMS} \PYG{o}{*} \PYG{l+m+mi}{25}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Full width at half maximum in channels (FWHM)}
\PYG{n}{FWHM\PYGZus{}lims} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} channels}
\PYG{c+c1}{\PYGZsh{} Mean channel position (MEAN)}
\PYG{n}{MEAN\PYGZus{}lims} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.25} \PYG{o}{*} \PYG{n}{NCHANNELS}\PYG{p}{,} \PYG{l+m+mf}{0.75} \PYG{o}{*} \PYG{n}{NCHANNELS}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Indicate whetehre the data created here will be used as a training set}
\PYG{c+c1}{\PYGZsh{} (a.k.a. decide to store the \PYGZdq{}true\PYGZdq{} answers or not at the end)}
\PYG{n}{TRAINING\PYGZus{}SET} \PYG{o}{=} \PYG{n+nb+bp}{True}

\PYG{c+c1}{\PYGZsh{} Specify the pickle file to store the results in}
\PYG{n}{FILENAME} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{agd\PYGZus{}data\PYGZus{}science.pickle}\PYG{l+s+s1}{\PYGZsq{}}
\end{Verbatim}

With the above parameters specified, we can proceed with constructing
a set of synthetic training data composed of Gaussian functions with
known parameters (i.e., for which we know the ``true'' decompositon),
sampled randomly from the parameter ranges specified above. The
resulting data, including the channel values, spectral values and
error estimates, are stored in the pickle file specified above. If we
want this to be a training set (\code{TRAINING\_SET = True}), the ``true''
decomposition answers for estimating the accuracy of a decomposition
are also stored in the output file. For example, to construct a
synthetic dataset:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} GaussPy Example 1}
\PYG{c+c1}{\PYGZsh{} Create spectra with Gaussian profiles \PYGZhy{}cont\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Initialize}
\PYG{n}{agd\PYGZus{}data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{chan} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{NCHANNELS}\PYG{p}{)}
\PYG{n}{errors} \PYG{o}{=} \PYG{n}{chan} \PYG{o}{*} \PYG{l+m+mf}{0.} \PYG{o}{+} \PYG{n}{RMS} \PYG{c+c1}{\PYGZsh{} Constant noise for all spectra}

\PYG{c+c1}{\PYGZsh{} Begin populating data}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{NSPECTRA}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{spectrum\PYGZus{}i} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{NCHANNELS}\PYG{p}{)} \PYG{o}{*} \PYG{n}{RMS}

    \PYG{c+c1}{\PYGZsh{} Sample random components:}
    \PYG{n}{amps} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{NCOMPS}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{AMP\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{AMP\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{AMP\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{fwhms} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{NCOMPS}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{FWHM\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{FWHM\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{FWHM\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{means} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{NCOMPS}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{MEAN\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{MEAN\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{MEAN\PYGZus{}lims}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Create spectrum}
    \PYG{k}{for} \PYG{n}{a}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{amps}\PYG{p}{,} \PYG{n}{fwhms}\PYG{p}{,} \PYG{n}{means}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{spectrum\PYGZus{}i} \PYG{o}{+}\PYG{o}{=} \PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{(}\PYG{n}{chan}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Enter results into AGD dataset}
    \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{data\PYGZus{}list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{spectrum\PYGZus{}i}\PYG{p}{]}
    \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}values}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x\PYGZus{}values}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{chan}\PYG{p}{]}
    \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{errors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{errors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{errors}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} If training data, keep answers}
    \PYG{k}{if} \PYG{n}{TRAINING\PYGZus{}SET}\PYG{p}{:}
        \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{amplitudes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{amplitudes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{amps}\PYG{p}{]}
        \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fwhms}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fwhms}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{fwhms}\PYG{p}{]}
        \PYG{n}{agd\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{means}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{agd\PYGZus{}data}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{means}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{p}{[}\PYG{n}{means}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Dump synthetic data into specified filename}
\PYG{n}{pickle}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{agd\PYGZus{}data}\PYG{p}{,} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{FILENAME}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\section{Training the Algorithm}
\label{tutorial:training-the-algorithm}
With a real or synthetic training dataset in hand, we will apply AGD
to the training dataset and compare the results with the known
underlying decompositon to determine the optimal value for the
smoothing parameter \(\alpha\).

To begin, import GaussianDecomposer from GaussPy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{gausspy.GaussianDecomposer} \PYG{k+kn}{as} \PYG{n+nn}{gp}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{gp}\PYG{o}{.}\PYG{n}{GaussianDecomposer}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Next, load the training dataset for analysis:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{g}\PYG{o}{.}\PYG{n}{load\PYGZus{}training\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{agd\PYGZus{}data.pickle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

We will begin with a one-phase decomposition (two-phase decomposiiton will be explained in later sections):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} One phase training}
\PYG{n}{g}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{phase}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{one}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Next, we set the signal to noise ratio (SNR) threshold below which AGD will not be allowed to include Gaussian functions in the model:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} threshold below which Gaussian components will not be fit}
\PYG{n}{g}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SNR\PYGZus{}thresh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{)}
\end{Verbatim}

Finally, we specify an initial guess for the \$alpha\$ value {[}{\color{red}\bfseries{}**}how close does this have to be?{]} and begint he training process:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} initial guess for the alpha value}
\PYG{n}{g}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{n}{alpha1\PYGZus{}initial} \PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{p}{)}
\end{Verbatim}

GausspPy will iterate over a range of \$alpha\$ values and compare the decomposition associated with each \$alpha\$ value to the correct decomposition specified within the training dataset to maximize the accuracy of the decomposition.

Once the training is completed, we can view the ``trained'' value of alpha by looking at the attribute of our GaussianDecomposer instance.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} get the parameters attribute of g, which is a dictionary of important}
\PYG{c+c1}{\PYGZsh{} variables}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{g}\PYG{o}{.}\PYG{n}{p}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{alpha1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
